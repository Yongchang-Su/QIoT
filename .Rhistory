k = 0
repeat{
error = c(error, sum((b-beta)^2))
gradient = grad(X, y, beta) + grad_h(beta, group, mu)
t = backtracking(X, y, beta, gradient)
gam1 = beta - t*gradient
beta1 = gam1 + k/(k+3)*(gam1-gam0)
if(loglikelihood(X,y,beta)-loglikelihood(X,y,beta1)<1e-6){
break
}
beta = beta1
gam0 = gam1
k = k + 1
}
return(list(beta = beta, error = error/error[1]))
}
res_gd_ac = GD_smooth_ac(X, y, b, 0.1, group)
plot(1:length(res_gd_ac$error), res_gd_ac$error)
b = rep(0:4, each = 10) + 0.1*rnorm(50)
group = rep(1:5, each = 10)
n = 100
X = matrix(rnorm(50*n), ncol = 50)
y = 2*rbinom(n, 1, 1/(1+exp(-X%*%b)))-1
res = PGD(X, y, b, 0.1, group)
plot(1:length(res$error), res$error)
res_ac = PGD_ac(X, y, b, 0.1, group)
lines(1:length(res_ac$error), res_ac$error)
res_gd_ac = GD_smooth_ac(X, y, b, 0.1, group)
lines(1:length(res_gd_ac$error), res_gd_ac$error)
plot(1:length(res$error), res$error, xlim = c(0,500), type = "l")
lines(1:length(res_ac$error), res_ac$error,type = "l")
lines(1:length(res_gd_ac$error), res_gd_ac$error,type = "l")
plot(1:length(res$error), res$error, xlim = c(0,300), type = "l", ylab = "loss_ratio", xlab = "iteration")
lines(1:length(res_ac$error), res_ac$error,type = "l", col = 2, lty = 2)
lines(1:length(res_gd_ac$error), res_gd_ac$error,type = "l", col = 3, lty = 3)
legend("topright", legend = c("proximal gradient", "accelerated proximal gradient", "accelerated gradient smooth"), col = 1:3, lty = 1:3)
q()
install.packages("haven")
library(haven)
install.packages("rlanb")
install.packages("rlang")
install.packages("rlang")
install.packages("haven")
source('C:/Users/ycsuf/Box/Multiple Stephenson/Code20221005/New Rank Score Function 10042022.R')
source('C:/Users/ycsuf/Box/Multiple Stephenson/Code20221005/Fun_multiple_stephenson.R')
library(gurobi)
library(devtools)
library(QIoT)
library(psych)
library(randomizr)
com_working = function(Z, Y, block, c, methods.list.all){
if(!is.factor(block)){
block = as.factor(block)
}
total.list = list()
n = length(methods.list.all)
N = length(Y)
B = length(levels(block))
block.levels = levels(block)
## calculate numbers of observations in each block
nb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == block.levels[i])
}
for (l in 1:n){
method.list.all = methods.list.all[[l]]
Tlist = list()
for(i in 1:B){
Zb = Z[block == block.levels[i]]
Yb = Y[block == block.levels[i]]
Ti = matrix(nrow = 2, ncol = nb[i] + 1)
Ti[1,] = 0:nb[i]
for(ii in 0:nb[i]){
if(length(method.list.all)==1){
method.list = method.list.all[[1]]
}else{
method.list = method.list.all[[i]]
}
Ti[2, ii+1] = min_stat(Zb, Yb, nb[i]-ii, c, method.list = method.list)
}
Tlist[[i]] = Ti
}
total.list[[l]] <- Tlist
}
return(total.list)
}
########################################################
### function for implement Gurobi for our ILP problem
########################################################
## two major changes:
##  (1) change in objective function statement
##  (2) allow eta to have negative value
Gurobi_sol_com <- function(coeflists, p, exact = TRUE){
model = list()
Q = NULL
H = length(coeflists)
B = length(coeflists[[1]])
nb = vector(length = B)
for (h in 1 : H){
coeflist = coeflists[[h]]
for (i in 1 : B){
Q = c(Q, coeflist[[i]][2,])
}
}
Q1 <- c(rep(0, length(Q)), 1)
#  Q1 <- c(Q, 1)
A_final <- c(Q, -1)    ## will add this as a final constraint
for (i in 1 : B){
nb[i] = ncol(coeflist[[i]]) ## this does not change by choice of SRSS(Stratified Rank Sum Statistic)
}
HB = H * B
nb2 = rep(nb, length(coeflists))  ## added
n = length(Q1)
A = matrix(0, nrow = H * (B + 1) + 1, ncol = n) ## added one row one column each
indx = c(0, cumsum(nb2))
for (i in 1 : HB){
A[i, (indx[i] + 1):indx[i+1]] = 1
}
for (h in 1 : H){
for (i in 1 : B) {
A[HB + h,  ((h-1) * sum(nb)+1) : (h * sum(nb))]  =
rep(coeflist[[i]][1,], B)
}
}
A[H * (B+1) + 1, ] = A_final
model$A = A
model$obj = Q1
model$modelsense = "min"
model$rhs = c(rep(1, HB), rep(p, H), 0)
model$sense = c(rep("=", HB), rep("<=", H), "<=" )
model$lb = c(rep(0, length(Q)), -Inf)
#  model$vtype = vec(B = length = length(Q1))
if(exact){
model$vtype = c(rep("B", length(Q)), "C")
}
gurobi(model)           ## can omit this when we only want to check the output, not the optimization process
params <- list(OutputFlag = 0)
result = gurobi::gurobi(model,params)
return(list(sol = result$x, obj = result$objval))
}
############################################
# test whether functions works
############################################
# simulation data generation
s = 20
n = 50
m = 0.5 * n
N = s * n
k = ceiling(0.9 * N)
p = N - k
c = 0
simulation_Z <- as.data.frame(block.random(n = N, c(block = s)))
simulation_Z$block <- as.factor(simulation_Z$block)
head(simulation_Z)
levels(simulation_Z$block)
test_Z <- block_ra(blocks = simulation_Z$block)
table(test_Z, simulation_Z$block)
Y1 = 2 + rnorm(N)
Y0 = rnorm(N)
Z = block_ra(blocks = simulation_Z$block)
Y = Z * Y1 + (1-Z) * Y0
Z_block <- simulation_Z$block
method.list.4 = list(name = "Stephenson",
s = 15,
)
method.list.all.4[[1]] <- method.list.4
method.list.all.4 <- list()
method.list.4 = list(name = "Stephenson",
s = 15
)
method.list.all.4[[1]] <- method.list.4
method.list.all.4[[1]] <- method.list.4
class(Z)
class(Y)
class(Z_block)
k
c
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4, opt.method = "ILP" )
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4, opt.method = "ILP_gurobi" )
coeflists = com_working(Z, Y, block = Z_block, c = c, methods.list.all = methods.list.all)
Gurobi_sol_com(coeflists, p, exact = TRUE)
method.list.all.4[[1]] <- method.list.4
methods.list.all <- list(method.list.all.4)
coeflists = com_working(Z, Y, block = Z_block, c = c, methods.list.all = methods.list.all)
method.list.4 = list(name = "Stephenson",
s = 15,
standardize = TRUE
)
method.list.all.4[[1]] <- method.list.4
methods.list.all <- list(method.list.all.4)
coeflists = com_working(Z, Y, block = Z_block, c = c, methods.list.all = methods.list.all)
Gurobi_sol_com(coeflists, p, exact = TRUE)
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4, opt.method = "ILP_gurobi" )
method.list.all.4 <- list()
method.list.4 = list(name = "Stephenson",
s = 15,
standardize = FALSE
)
method.list.all.4[[1]] <- method.list.4
methods.list.all <- list(method.list.all.4)
# check whether our function works
coeflists = com_working(Z, Y, block = Z_block, c = c, methods.list.all = methods.list.all)
Gurobi_sol_com(coeflists, p, exact = TRUE)
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4)
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4)
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4)
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4)
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4)
s = 20
n = 50
m = 0.5 * n
N = s * n
k = ceiling(0.9 * N)
p = N - k
c = 0
simulation_Z <- as.data.frame(block.random(n = N, c(block = s)))
simulation_Z$block <- as.factor(simulation_Z$block)
head(simulation_Z)
levels(simulation_Z$block)
test_Z <- block_ra(blocks = simulation_Z$block)
table(test_Z, simulation_Z$block)
Y1 = 2 + rnorm(N)
Y0 = rnorm(N)
Z = block_ra(blocks = simulation_Z$block)
Y = Z * Y1 + (1-Z) * Y0
Z_block <- simulation_Z$block
# testing methods; for new rank_score method
method.list.all.4 <- list()
method.list.4 = list(name = "Stephenson",
s = 15,
standardize = FALSE
)
method.list.all.4[[1]] <- method.list.4
methods.list.all <- list(method.list.all.4)
# check whether our function works
coeflists = com_working(Z, Y, block = Z_block, c = c, methods.list.all = methods.list.all)
Gurobi_sol_com(coeflists, p, exact = TRUE)
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
method.list.4 = list(name = "Stephenson",
s = 15
)
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4, opt.method = "ILP" )
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = as.factor(Z_block), k, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
c
k
method.list.all.4
setwd("C:/Users/ycsuf/Box/Stratified Quantile/Code_Submission_08162022")
o = readRDS("o.rds")
md <- o$data
## permute the order of all units
set.seed(1)
md <- md[sample(nrow(md)), ]
Y = md$cadmium
block = md$mset
Z = md$z
method.list.all = list()
method.list.all[[1]] = list(name = "Wilcoxon")
##### Confidence region calculated using dynamic programming with switching labels
LB_switch = QIoT::block_conf_quant_larger(Z,Y,block,method.list.all,opt.method = "Greedy", ties = "fix", switch = TRUE, null.max=10^5)
method.list.all = list()
method.list.all[[1]] = list(name = "Stephenson", s = 10)
##### Confidence region calculated using dynamic programming with switching labels
LB_switch = QIoT::block_conf_quant_larger(Z,Y,block,method.list.all,opt.method = "Greedy", ties = "fix", switch = TRUE, null.max=10^5)
s = 20
n = 50
m = 0.5 * n
N = s * n
k = ceiling(0.9 * N)
p = N - k
c = 0
simulation_Z <- as.data.frame(block.random(n = N, c(block = s)))
simulation_Z$block <- as.factor(simulation_Z$block)
head(simulation_Z)
levels(simulation_Z$block)
test_Z <- block_ra(blocks = simulation_Z$block)
table(test_Z, simulation_Z$block)
Y1 = 2 + rnorm(N)
Y0 = rnorm(N)
Z = block_ra(blocks = simulation_Z$block)
Y = Z * Y1 + (1-Z) * Y0
Z_block <- simulation_Z$block
head(Z)
head(Y)
head(Z_block)
QIoT::min_stat_block(Z, Y, block = Z_block, k, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 990, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 910, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 920, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 930, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 940, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 950, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 960, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
coeflists
source('C:/Users/ycsuf/Box/Stratified Quantile/Code_2nd_Submission/RI_Quantile.R')
QIoT::min_stat_block(Z, Y, block = Z_block, 950, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
min_stat_block(Z, Y, block = Z_block, 950, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
## O(nlogn) method of Greedy algorithm
LpGreedy = function(coeflist, p, trans = TRUE, a = NULL, dic = NULL){
if(p<0){
if(trans){
return(Inf)
}else{
return(-Inf)
}
}
coeflist1 = coeflist
if(trans){
## convert to a maximization problem
sm = 0
for(s in 1:length(coeflist)){
sm = sm + coeflist[[s]][2,1]
coeflist1[[s]][2,] = coeflist[[s]][2,1] - coeflist[[s]][2,]
}
## remove Lp dominated terms to reduce complexity
lpres = LpDominateRemove(coeflist1)
coeflist1 = lpres$coeflist
dictionary = lpres$dictionary
}else{
if(is.null(dic)){
dictionary = coeflist
for(s in 1:length(coeflist)){
dictionary[[s]] = 1:length(coeflist[[s]])
}
}else{
dictionary = dic
}
}
if(is.null(a)){
a = find_a(coeflist1)
}
cumsum_a1 = cumsum(a[1,])
cumsum_a2 = cumsum(a[1,]*a[2,])
pos = sum(cumsum_a1<p)
## calculate objective value and solution
sol = list()
for(s in 1:length(coeflist)){
sol[[s]] = c(rep(0, ncol(coeflist[[s]])))
}
if(pos==0){
res = p *a[2,1]
pos3 = 0
}else if(pos == length(cumsum_a1)){
res = cumsum_a2[pos]
for(s in 1:length(coeflist)){
sol[[s]][ncol(coeflist[[s]])] = 1
}
if(trans){
return(list(obj = as.numeric(sm - res), sol = sol, alpha = 0))
}else{
return(list(obj = as.numeric(res), sol = sol, alpha = 0))
}
}else{
res = cumsum_a2[pos] + (p - cumsum_a1[pos])*a[2,pos+1]
pos3 = a[3,1:pos]
}
# for(s in 1:length(coeflist1)){
#   count_s = sum(pos3 == s) + 1
#   if(s!=a[3,pos+1]){
#     index = coeflist1[[s]][1, count_s] + 1
#     sol[[s]][index] = 1
#   }else{
#     index1 = coeflist1[[s]][1,count_s]+1
#     index2 = coeflist1[[s]][1,count_s+1]+1
#     sol[[s]][index2] = (p - ifelse(pos==0, 0, cumsum_a1[pos]))/a[1,pos+1]
#     sol[[s]][index1] = 1 - sol[[s]][index2]
#   }
for(s in 1:length(coeflist1)){
count_s = sum(pos3 == s) + 1
if(s!=a[3,pos+1]){
sol[[s]][dictionary[[s]][count_s]] = 1
}else{
sol[[s]][dictionary[[s]][count_s+1]] = (p - ifelse(pos==0, 0, cumsum_a1[pos]))/a[1,pos+1]
sol[[s]][dictionary[[s]][count_s]] = 1 - sol[[s]][dictionary[[s]][count_s+1]]
}
}
if(trans){
return(list(obj = sm - as.numeric(res), sol = sol, alpha = a[2,pos+1]))
}else{
return(list(obj = as.numeric(res), sol = sol, alpha = a[2,pos+1]))
}
}
### bounds of the infimum of test statistics
# opt.method = "", "Greedyn", "DP", "DKW", "Mcknap", "LP", "ILP", "LP_gurobi" or "ILP_gurobi")
min_stat_block <- function(Z, Y, block, k, c, method.list.all, opt.method="Greedy"){
N = length(Z)
flag = (Z==1)
Y1 = Y
block1 = block
Y1[1:sum(flag)] = Y[flag]
Y1[(sum(flag)+1):N] = Y[!flag]
block1[1:sum(flag)] = block[flag]
block1[(sum(flag)+1):N] = block[!flag]
Z1 = c(rep(1, sum(flag)), rep(0, N-sum(flag)))
Z2 = rev(Z1)
Y2 = rev(Y1)
block2 = rev(block1)
coeflist1 = test_stat_matrix_block(Z1, Y1, block1, c, method.list.all)
coeflist2 = test_stat_matrix_block(Z2, Y2, block2, c, method.list.all)
if(opt.method == "Greedy"){
return(list(upper = LpGreedy_On(coeflist2, N - k)$obj, lower =  LpGreedy_On(coeflist1, N - k)$obj))
}
if(opt.method == "DP"){
return(list(upper = DP_C(coeflist2, N - k)$obj, lower =DP_C(coeflist1, N - k)$obj))
}
if(opt.method == "Mcknap"){
return(list(upper = BB_Mcknap_C(coeflist2, N - k)$obj, lower = BB_Mcknap_C(coeflist1, N - k)$obj))
}
if(opt.method == "LP"){
return(list(upper = Lpsolve_sol(coeflist2, N - k, exact = FALSE), lower = Lpsolve_sol(coeflist1, N - k, exact = FALSE)))
}
if(opt.method == "ILP"){
return(list(upper = Lpsolve_sol(coeflist2, N - k, exact = TRUE), lower = Lpsolve_sol(coeflist1, N - k, exact = TRUE)))
}
}
min_stat_block(Z, Y, block = Z_block, 950, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
a = min_stat_block(Z, Y, block = Z_block, 950, c, method.list.all = method.list.all.4, opt.method = "Greedy" )$upper
a
a%10
a//10
a%%10
setwd("C:/Users/ycsuf/Box/Stratified Quantile")
QIoT::min_stat_block(Z, Y, block = Z_block, 960, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 960, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 960, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 960, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 960, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 960, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 960, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 960, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 960, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
QIoT::min_stat_block(Z, Y, block = Z_block, 960, c, method.list.all = method.list.all.4, opt.method = "Greedy" )
coeflists = test_stat_matrix_block(Z, Y, Z_block, 960, method.list.all.4)
Rcpp::sourceCpp("test.cpp")
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 960)
coeflists = test_stat_matrix_block(Z, Y, Z_block, 960, method.list.all.4)
LpGreedy_On_Ct(coeflists, 960)
coeflists[1]
coeflists = com_working(Z, Y, block = Z_block, c = c, methods.list.all = methods.list.all)
coeflists[1]
coeflists[[1]]
coeflists = test_stat_matrix_block(Z, Y, Z_block, 0, method.list.all.4)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 1)
LpGreedy_On_Ct(coeflists, 1000)
coeflists
Rcpp::sourceCpp("test.cpp")
Rcpp::sourceCpp("test.cpp")
Rcpp::sourceCpp("test.cpp")
LpGreedy_On_Ct(coeflists, 1000)
LpGreedy_On_Ct(coeflists, 960)
Rcpp::sourceCpp("test.cpp")
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
Rcpp::sourceCpp("test.cpp")
coeflists = test_stat_matrix_block(Z, Y, Z_block, 0, method.list.all.4)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
Rcpp::sourceCpp("test.cpp")
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On(coeflists, p)
LpGreedy_On(coeflists, p)$obj
Rcpp::sourceCpp("test.cpp")
LpGreedy_On_Ct(coeflists, 960)
Rcpp::sourceCpp("test.cpp")
LpGreedy_On_Ct(coeflists, 960)
LpGreedy_On(coeflists, 960)
LpGreedy_On(coeflists, 960)$obj
LpGreedy_On(coeflists, 960)$obj
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On(coeflists, 40)$obj
Rcpp::sourceCpp("test.cpp")
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On(coeflists, 40)$obj
LpGreedy_On(coeflists, 40)$obj
Rcpp::sourceCpp("test.cpp")
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 40)
LpGreedy_On_Ct(coeflists, 40)
setwd("C:/Users/ycsuf/Box/Stratified Quantile/QIoT")
library(devtools)
document()
