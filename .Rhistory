method.list.all[[1]] = list(name = "Wilcoxon")
### Test null hypothesis that 90% quantile of treatment effects is less than or equal to 0.
p1 = pval_quantile_scre(Z=Z,Y=Y,block=block,k=floor(0.9*length(Y)),c=0,method.list.all=method.list.all)
### Test null hypothesis that 90% quantile of treatment effects is greater than or equal to 1.
p2 = pval_quantile_scre(Z=Z,Y=Y,block=block,k=floor(0.9*length(Y)),c=1,alternative="greater",method.list.all=method.list.all)
p1
p2
?QIoT::pval_quantile_sen
data("cadmium")
Y = cadmium$cadmium
block = cadmium$mset
Z = cadmium$z
### use stratified Wilcoxon test statistics for all strata.
method.list.all = list()
method.list.all[[1]] = list(name = "Wilcoxon")
### Test null hypothesis that 90% quantile of treatment effects is less than or equal to 0 under Gamma = 3.
p1 = pval_quantile_sen(Z=Z,Y=Y,block=block,k=floor(0.9*length(Y)),c=0, gam = 3, method.list.all=method.list.all)
### Test null hypothesis that 90% quantile of treatment effects is greater than or equal to 1 under Gamma = 3.
p2 = pval_quantile_sen(Z=Z,Y=Y,block=block,k=floor(0.9*length(Y)),c=1,alternative="greater",gam=3,method.list.all=method.list.all)
p1
p2
?QIoT::ci_quantile_scre
data("cadmium")
Y = cadmium$cadmium
block = cadmium$mset
Z = cadmium$z
n = length(Z)
### use stratified Wilcoxon test statistics for all strata.
method.list.all = list()
method.list.all[[1]] = list(name = "Wilcoxon")
### Calculate 90% confidence intervals for the top 10 percent largest treatment effects.
CIs = ci_quantile_scre(Z,Y,block,quantiles=floor(0.9*n):n,alternative = "two.sided",method.list.all=method.list.all,opt.method = "Greedy", switch = TRUE, null.max=10^5)
Cia
CIs
?QIoT::pval_quantile_sen
data("cadmium")
Y = cadmium$cadmium
block = cadmium$mset
Z = cadmium$z
### use stratified Wilcoxon test statistics for all strata.
method.list.all = list()
method.list.all[[1]] = list(name = "Wilcoxon")
### Test null hypothesis that 90% quantile of treatment effects is less than or equal to 0 under Gamma = 3.
p1 = pval_quantile_sen(Z=Z,Y=Y,block=block,k=floor(0.9*length(Y)),c=0, gam = 3, method.list.all=method.list.all)
### Test null hypothesis that 90% quantile of treatment effects is greater than or equal to 1 under Gamma = 3.
p2 = pval_quantile_sen(Z=Z,Y=Y,block=block,k=floor(0.9*length(Y)),c=1,alternative="greater",gam=3,method.list.all=method.list.all)
?QIoT::ci_quantile_sen
data("cadmium")
Y = cadmium$cadmium
block = cadmium$mset
Z = cadmium$z
n = length(Z)
### use stratified Wilcoxon test statistics for all strata.
method.list.all = list()
method.list.all[[1]] = list(name = "Wilcoxon")
### Calculate 90% confidence intervals for the top 10 percent largest treatment effects under Gamma = 3.
CIs = ci_quantile_sen(Z,Y,block,gam=3,quantiles=floor(0.9*n):n,alternative = "two.sided",method.list.all=method.list.all,opt.method = "Greedy", switch = TRUE, confidence = 0.9)
CIs
setwd("C:/Users/ycsuf/Box/Stratified Quantile/QIoT")
library(devtools)
document()
S = 10
n = 10
N = S*n
block = rep(1:S, each = n)
Z = rep(rep(c(0,1), 5), S)
Y = rnorm(S*n) + Z*(5+rnorm(S*n))
### Choose Stephenson rank sum as our test statistic
method.list.all = list()
method.list.all[[1]] = list(name = "Stephenson", s=3)
### Calculate p-values for null that 10th largest treatment effect is no more than 3
pval_quantile_scre(Z, Y, block, k = 90, c = 3, method.list.all)
pval_quantile_scre(Z, Y, block, k = 90, c = 3, method.list.all = method.list.all)
?pval_quantile_scre
data("cadmium")
Y = cadmium$cadmium
block = cadmium$mset
Z = cadmium$z
### use stratified Wilcoxon test statistics for all strata.
method.list.all = list()
method.list.all[[1]] = list(name = "Wilcoxon")
### Test null hypothesis that 90% quantile of treatment effects is less than or equal to 0.
p1 = pval_quantile_scre(Z=Z,Y=Y,block=block,k=floor(0.9*length(Y)),c=0,method.list.all=method.list.all)
### Test null hypothesis that 90% quantile of treatment effects is greater than or equal to 1.
p2 = pval_quantile_scre(Z=Z,Y=Y,block=block,k=floor(0.9*length(Y)),c=1,alternative="greater",method.list.all=method.list.all)
unload("QIoT")
install_github("Yongchang-Su/QIoT")
library(QIoT)
S = 10
n = 10
N = S*n
block = rep(1:S, each = n)
Z = rep(rep(c(0,1), 5), S)
Y = rnorm(S*n) + Z*(5+rnorm(S*n))
### Choose Stephenson rank sum as our test statistic
method.list.all = list()
method.list.all[[1]] = list(name = "Stephenson", s=3)
### Calculate p-values for null that 10th largest treatment effect is no more than 3
pval_quantile_scre(Z, Y, block, k = 90, c = 3, method.list.all=method.list.all)
CIs = ci_quantile_scre(Z, Y, block, method.list.all)
CI_lower = CIs$LB
Cis
CIs
?ci_quantile_scre
.re.restart()
.rs.restartR()
?ci_quantile_scre
CIs = ci_quantile_scre(Z, Y, block, method.list.all = method.list.all)
CI_lower = CIs$LB
CIs
Z
block
ci_quantile_scre(Z, Y, block, method.list.all = method.list.all)
library(QIoT)
ci_quantile_scre(Z, Y, block, method.list.all = method.list.all)
unload("QIoT")
install_github("Yongchang-Su/QIoT")
library(QIoT)
S = 10
n = 10
N = S*n
block = rep(1:S, each = n)
Z = rep(rep(c(0,1), 5), S)
Y = rnorm(S*n) + Z*(5+rnorm(S*n))
### Choose Stephenson rank sum as our test statistic
method.list.all = list()
method.list.all[[1]] = list(name = "Stephenson", s=3)
### Calculate p-values for null that 10th largest treatment effect is no more than 3
pval_quantile_scre(Z, Y, block, k = 90, c = 3, method.list.all = method.list.all)
CIs = ci_quantile_scre(Z, Y, block, method.list.all)
CI_lower = CIs$LB
CIs
CIs = ci_quantile_scre(Z, Y, block, method.list.all=method.list.all)
CI_lower = CIs$LB
CIs
ci_quantile_scre(Z,Y,block,alternative = "two.sided",method.list.all=method.list.all,opt.method = "Greedy", switch = TRUE, null.max=10^5)
CIs = ci_quantile_scre(Z, Y, block, alternative = "upper", method.list.all=method.list.all)
length(Z)
length(Y)
method.list.all
if(!is.factor(block)){
block = as.factor(block)
}
levels(block) = 1:length(levels(block))
n = length(Z)
mn = sum(Z)
B = length(levels(block))
if(switch){
nb = rep(NA, B)
zb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == levels(block)[i])
zb[i] = sum(Z[block == levels(block)[i]])
}
for(i in 1:B){
if(zb[i]<nb[i]/2){
Z[block == levels(block)[i]] = 1 - Z[block == levels(block)[i]]
Y[block == levels(block)[i]] = -Y[block == levels(block)[i]]
}
}
}
nb = rep(NA, B)
zb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == levels(block)[i])
zb[i] = sum(Z[block == levels(block)[i]])
}
for(i in 1:B){
if(zb[i]<nb[i]/2){
Z[block == levels(block)[i]] = 1 - Z[block == levels(block)[i]]
Y[block == levels(block)[i]] = -Y[block == levels(block)[i]]
}
}
CIs = ci_quantile_scre(Z,Y,block,quantiles=floor(0.9*n):n,alternative = "two.sided",method.list.all=method.list.all,opt.method = "Greedy", switch = TRUE, null.max=10^5)
CIs = ci_quantile_scre(Z,Y,block,alternative = "two.sided",method.list.all=method.list.all,opt.method = "Greedy", switch = TRUE, null.max=10^5)
unload("QIoT")
install_github("Yongchang-Su/QIoT")
library(QIoT)
CIs = ci_quantile_scre(Z, Y, block, method.list.all = method.list.all)
CI_lower = CIs$LB
plot(CI_lower[CI_lower>-Inf], (1:length(CI_lower))[CI_lower>-Inf], type = "p", xlab = "c", ylab = "k", cex = 1.5, col = "black", pch = 18)
segments(CI_lower[CI_lower>-Inf], (1:length(CI_lower))[CI_lower>-Inf], 5, (1:length(CI_lower))[CI_lower>-Inf], lty= 2)
CIs = ci_quantile_scre(Z, Y, block, method.list.all = method.list.all)
CI_lower = CIs$LB
plot(CI_lower[CI_lower>-Inf], (1:length(CI_lower))[CI_lower>-Inf], type = "p", xlab = "c", ylab = "k", cex = 1.5, col = "black", pch = 18)
segments(CI_lower[CI_lower>-Inf], (1:length(CI_lower))[CI_lower>-Inf], 5, (1:length(CI_lower))[CI_lower>-Inf], lty= 2)
CIs = ci_quantile_scre(Z, Y, block, method.list.all = method.list.all)
CI_lower = CIs$LB
plot(CI_lower[CI_lower>-Inf], (1:length(CI_lower))[CI_lower>-Inf], type = "p", xlab = "c", ylab = "k", cex = 1.5, col = "black", pch = 18, xlim = c(0,6))
segments(CI_lower[CI_lower>-Inf], (1:length(CI_lower))[CI_lower>-Inf], 6, (1:length(CI_lower))[CI_lower>-Inf], lty= 2)
CIs = ci_quantile_scre(Z, Y, block, method.list.all = method.list.all)
CI_lower = CIs$LB
plot(CI_lower[CI_lower>-Inf], (1:length(CI_lower))[CI_lower>-Inf], type = "p", xlab = "c", ylab = "k", cex = 1.5, col = "black", pch = 18, xlim = c(1,6))
segments(CI_lower[CI_lower>-Inf], (1:length(CI_lower))[CI_lower>-Inf], 6, (1:length(CI_lower))[CI_lower>-Inf], lty= 2)
install_github("Yongchang-Su/QIoT")
unload("QIoT")
library(gurobi)
library(devtools)
install_github("Yongchang-Su/QIoT", build_vignettes = TRUE)
library(QIoT)
data("cadmium")
Y = cadmium$cadmium
block = cadmium$mset
Z = cadmium$z
method.list.all = list()
method.list.all[[1]] = list(name = "Wilcoxon")
LB_switch = QIoT::ci_quantile_scre(Z,Y,block,method.list.all=method.list.all,opt.method = "Greedy", switch = TRUE, null.max=10^5)
LB_noswitch = QIoT::ci_quantile_scre(Z,Y,block,method.list.all=method.list.all,opt.method = "Greedy", switch = FALSE, null.max=10^5)
LB_switch
LB_switch = QIoT::ci_quantile_scre(Z,Y,block,method.list.all=method.list.all,opt.method = "Greedy", switch = TRUE, null.max=10^5)$LB
LB_noswitch = QIoT::ci_quantile_scre(Z,Y,block,method.list.all=method.list.all,opt.method = "Greedy", switch = FALSE, null.max=10^5)$LB
plot(LB_switch[LB_switch>-Inf], (1:length(LB_switch))[LB_switch>-Inf], type = "p", xlim = c(-1.5, 1), xlab = "c", ylab = "k", cex = 0.5)
points(LB_noswitch[LB_noswitch>-Inf], (1:length(LB_noswitch))[LB_noswitch>-Inf], cex = 0.5, col = "grey")
abline(v = 0, lty = 2)
legend("topleft", pch = 1, col = c("black", "grey"),legend = c("switching labels", "no switching"))
gammas = rep(0, 7)
enum = 1
gam = 1
for(quant in 0.65 + 0.05*(1:7)){
k = floor(quant * length(Z))
while(1){
pval = QIoT::pval_quantile_sen(Z, Y, block, k, 0, gam=gam, method.list.all=method.list.all, switch = TRUE)$upper
if(pval > 0.1){
gammas[enum] = max(gam - 0.1, 1)
enum = enum + 1
break
}
gam = gam + 0.1
}
}
gammas = rep(0, 7)
enum = 1
gam = 1
for(quant in 0.65 + 0.05*(1:7)){
k = floor(quant * length(Z))
while(1){
pval = QIoT::pval_quantile_sen(Z, Y, block, k, 0, gam=gam, method.list.all=method.list.all)$upper
if(pval > 0.1){
gammas[enum] = max(gam - 0.1, 1)
enum = enum + 1
break
}
gam = gam + 0.1
}
}
print(gammas)
gammas = rep(0, 7)
enum = 1
gam = 1
#### Performing switching label trick.
nb = rep(NA, B)
zb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == levels(block)[i])
zb[i] = sum(Z[block == levels(block)[i]])
}
for(i in 1:B){
if(zb[i]<nb[i]/2){
Z[block == levels(block)[i]] = 1 - Z[block == levels(block)[i]]
Y[block == levels(block)[i]] = -Y[block == levels(block)[i]]
}
}
for(quant in 0.65 + 0.05*(1:7)){
k = floor(quant * length(Z))
while(1){
pval = QIoT::pval_quantile_sen(Z, Y, block, k, 0, gam=gam, method.list.all=method.list.all)$upper
if(pval > 0.1){
gammas[enum] = max(gam - 0.1, 1)
enum = enum + 1
break
}
gam = gam + 0.1
}
}
print(gammas)
library(gurobi)
library(devtools)
install_github("Yongchang-Su/QIoT", build_vignettes = TRUE)
library(QIoT)
library(gurobi)
library(devtools)
install_github("Yongchang-Su/QIoT", build_vignettes = TRUE)
library(QIoT)
library(gurobi)
library(devtools)
install_github("Yongchang-Su/QIoT", build_vignettes = TRUE)
library(QIoT)
unload("QIoT")
library(gurobi)
library(devtools)
install_github("Yongchang-Su/QIoT", build_vignettes = TRUE)
library(QIoT)
data("cadmium")
Y = cadmium$cadmium
block = cadmium$mset
Z = cadmium$z
method.list.all = list()
method.list.all[[1]] = list(name = "Wilcoxon")
gammas = rep(0, 7)
enum = 1
gam = 1
#### Performing switching label trick.
nb = rep(NA, B)
zb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == levels(block)[i])
zb[i] = sum(Z[block == levels(block)[i]])
}
for(i in 1:B){
if(zb[i]<nb[i]/2){
Z[block == levels(block)[i]] = 1 - Z[block == levels(block)[i]]
Y[block == levels(block)[i]] = -Y[block == levels(block)[i]]
}
}
for(quant in 0.65 + 0.05*(1:7)){
k = floor(quant * length(Z))
while(1){
pval = QIoT::pval_quantile_sen(Z, Y, block, k, 0, gam=gam, method.list.all=method.list.all)$upper
if(pval > 0.1){
gammas[enum] = max(gam - 0.1, 1)
enum = enum + 1
break
}
gam = gam + 0.1
}
}
print(gammas)
B
gammas = rep(0, 7)
enum = 1
gam = 1
#### Performing switching label trick.
B = length(levels(block))
nb = rep(NA, B)
zb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == levels(block)[i])
zb[i] = sum(Z[block == levels(block)[i]])
}
for(i in 1:B){
if(zb[i]<nb[i]/2){
Z[block == levels(block)[i]] = 1 - Z[block == levels(block)[i]]
Y[block == levels(block)[i]] = -Y[block == levels(block)[i]]
}
}
levels(block)
data("cadmium")
Y = cadmium$cadmium
block = as.factor(cadmium$mset)
Z = cadmium$z
method.list.all = list()
method.list.all[[1]] = list(name = "Wilcoxon")
gammas = rep(0, 7)
enum = 1
gam = 1
#### Performing switching label trick.
B = length(levels(block))
nb = rep(NA, B)
zb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == levels(block)[i])
zb[i] = sum(Z[block == levels(block)[i]])
}
for(i in 1:B){
if(zb[i]<nb[i]/2){
Z[block == levels(block)[i]] = 1 - Z[block == levels(block)[i]]
Y[block == levels(block)[i]] = -Y[block == levels(block)[i]]
}
}
for(quant in 0.65 + 0.05*(1:7)){
k = floor(quant * length(Z))
while(1){
pval = QIoT::pval_quantile_sen(Z, Y, block, k, 0, gam=gam, method.list.all=method.list.all)$upper
if(pval > 0.1){
gammas[enum] = max(gam - 0.1, 1)
enum = enum + 1
break
}
gam = gam + 0.1
}
}
.rs.restartR()
gammas = rep(0, 7)
enum = 1
gam = 1
#### Performing switching label trick.
B = length(levels(block))
nb = rep(NA, B)
zb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == levels(block)[i])
zb[i] = sum(Z[block == levels(block)[i]])
}
for(i in 1:B){
if(zb[i]<nb[i]/2){
Z[block == levels(block)[i]] = 1 - Z[block == levels(block)[i]]
Y[block == levels(block)[i]] = -Y[block == levels(block)[i]]
}
}
#### Find corresponding gammas
for(quant in 0.65 + 0.05*(1:7)){
k = floor(quant * length(Z))
while(1){
pval = QIoT::pval_quantile_sen(Z, Y, block, k, 0, gam=gam, method.list.all=method.list.all, ties = "upper")$upper
if(pval > 0.1){
gammas[enum] = max(gam - 0.1, 1)
enum = enum + 1
break
}
gam = gam + 0.1
}
}
data("cadmium")
Y = cadmium$cadmium
block = as.factor(cadmium$mset)
Z = cadmium$z
method.list.all = list()
method.list.all[[1]] = list(name = "Wilcoxon")
gammas = rep(0, 7)
enum = 1
gam = 1
#### Find corresponding gammas
for(quant in 0.65 + 0.05*(1:7)){
k = floor(quant * length(Z))
while(1){
pval = QIoT::pval_quantile_sen(Z, Y, block, k, 0, gam=gam, method.list.all=method.list.all, ties = "upper")$upper
if(pval > 0.1){
gammas[enum] = max(gam - 0.1, 1)
enum = enum + 1
break
}
gam = gam + 0.1
}
}
gam
gammas
B = length(levels(block))
nb = rep(NA, B)
zb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == levels(block)[i])
zb[i] = sum(Z[block == levels(block)[i]])
}
for(i in 1:B){
if(zb[i]<nb[i]/2){
Z[block == levels(block)[i]] = 1 - Z[block == levels(block)[i]]
Y[block == levels(block)[i]] = -Y[block == levels(block)[i]]
}
}
for(quant in 0.65 + 0.05*(1:7)){
k = floor(quant * length(Z))
while(1){
pval = QIoT::pval_quantile_sen(Z, Y, block, k, 0, gam=gam, method.list.all=method.list.all, ties = "upper")$upper
if(pval > 0.1){
print(pval)
gammas[enum] = max(gam - 0.1, 1)
enum = enum + 1
break
}
gam = gam + 0.1
}
}
gammas = rep(0, 7)
enum = 1
gam = 1
for(quant in 0.65 + 0.05*(1:7)){
k = floor(quant * length(Z))
while(1){
pval = QIoT::pval_quantile_sen(Z, Y, block, k, 0, gam=gam, method.list.all=method.list.all, ties = "upper")$upper
if(pval > 0.1){
print(pval)
gammas[enum] = max(gam - 0.1, 1)
enum = enum + 1
break
}
gam = gam + 0.1
}
}
QIoT::pval_quantile_sen(Z, Y, block, k, 0, gam=1, method.list.all=method.list.all, ties = "upper")$upper
gammas = rep(0, 7)
enum = 1
gam = 1
for(quant in 0.65 + 0.05*(1:7)){
k = floor(quant * length(Z))
while(1){
pval = QIoT::pval_quantile_sen(Z, Y, block, k, 0, gam=gam, method.list.all=method.list.all, ties = "upper")$upper
if(pval > 0.1){
gammas[enum] = max(gam - 0.1, 1)
enum = enum + 1
break
}
gam = gam + 0.1
print(gam)
}
}
unload("QIoT")
library(gurobi)
library(devtools)
install_github("Yongchang-Su/QIoT", build_vignettes = TRUE)
library(QIoT)
library(gurobi)
library(devtools)
install_github("Yongchang-Su/QIoT", build_vignettes = TRUE)
library(QIoT)
library(gurobi)
library(devtools)
install_github("Yongchang-Su/QIoT", build_vignettes = TRUE)
install_github("Yongchang-Su/QIoT")
unload("QIoT")
file.path(R.home(), "bin/x64")
Sys.setenv(R_REMOTES_STANDALONE="true")
install_github("Yongchang-Su/QIoT")
