(coeflist1[[i]][2, pos+1]-coeflist1[[i]][2, pos])/(coeflist1[[i]][1, pos+1]-coeflist1[[i]][1, pos])))
Aminus = c(Aminus, ifelse(pos ==1, Inf,
(coeflist1[[i]][2, pos]-coeflist1[[i]][2, pos-1])/(coeflist1[[i]][1, pos]-coeflist1[[i]][1, pos-1])))
}else{
Aplus = c(Aplus, 0)
Aminus = c(Aminus, Inf)
s = i
a = Lpsol[[i]]
a[a>0] = c(1,0)
Lpsol[[i]] = a
}
}
cw = p - sum(LB_w)
cls = 1:n
cplus = vector(length = n)
cminus = cplus
cplus[1 + n - rank(Aplus, ties.method = "first")] = cls
cminus[rank(Aminus, ties.method = "first")] = cls
Aplus = c(Aplus, 0)
Aminus = c(Aminus, Inf)
z_l = 0
a = 1
b = 1
lst = RC_C(coeflist2[[s]],Lpres$obj-LB_p[s]+alpha*(cw+LB_w[s]),alpha,z_l)
Cs = vector(length = n)
Cs[s] = s
C = Cs[Cs]
t1 = 0
t2 = 0
t3 = 0
start = Sys.time()
repeat{
val = c(z_l, p, sum(LB_w[-C]),sum(LB_p[-C]))
start.time = Sys.time()
temp = RS_C(lst,C,Aplus,Aminus,val)
end.time = Sys.time()
t1 = t1 +difftime(end.time,start.time, units = "secs")
lst = temp$lst
z_l = temp$z
if(sum(C) == sum(1:length(coeflist2))|ncol(lst) == 0){break}
i = cplus[a]
a = a + 1
if(Cs[i] == 0){
Cs[i] = i
C = rev(Cs[Cs])
start.time = Sys.time()
R = RC_C(coeflist2[[i]],Lpres$obj-LB_p[i]+alpha*(cw+LB_w[i]),alpha,z_l)
end.time = Sys.time()
t2 = t2 +difftime(end.time,start.time, units = "secs")
if(ncol(R)>1){
start.time = Sys.time()
lst = add_C(lst, R, p)
end.time = Sys.time()
t3 = t3 +difftime(end.time,start.time, units = "secs")
}
}
val = c(z_l, p, sum(LB_w[-C]),sum(LB_p[-C]))
start.time = Sys.time()
temp = RS_C(lst,C,Aplus,Aminus,val)
end.time = Sys.time()
t1 = t1 +difftime(end.time,start.time, units = "secs")
lst = temp$lst
z_l = temp$z
if(sum(C) == sum(1:length(coeflist2))|ncol(lst) == 0){break}
i = cminus[b]
b = b + 1
if(Cs[i] == 0){
Cs[i] = i
C = rev(Cs[Cs])
start.time = Sys.time()
R = RC_C(coeflist2[[i]],Lpres$obj-LB_p[i]+alpha*(cw+LB_w[i]),alpha,z_l)
end.time = Sys.time()
t2 = t2 +difftime(end.time,start.time, units = "secs")
if(ncol(R)>1){
start.time = Sys.time()
lst = add_C(lst, R, p)
end.time = Sys.time()
t3 = t3 +difftime(end.time,start.time, units = "secs")
}
}
}
end = Sys.time()
t4 = difftime(end,start, units = "secs")
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
start = Sys.time()
repeat{
val = c(z_l, p, sum(LB_w[-C]),sum(LB_p[-C]))
start.time = Sys.time()
temp = RS_C(lst,C,Aplus,Aminus,val)
end.time = Sys.time()
t1 = t1 +difftime(end.time,start.time, units = "secs")
lst = temp$lst
z_l = temp$z
if(sum(C) == sum(1:length(coeflist2))|ncol(lst) == 0){break}
i = cplus[a]
a = a + 1
if(Cs[i] == 0){
Cs[i] = i
C = rev(Cs[Cs])
start.time = Sys.time()
R = RC_C(coeflist2[[i]],Lpres$obj-LB_p[i]+alpha*(cw+LB_w[i]),alpha,z_l)
end.time = Sys.time()
t2 = t2 +difftime(end.time,start.time, units = "secs")
if(ncol(R)>1){
start.time = Sys.time()
lst = add_C(lst, R, p)
end.time = Sys.time()
t3 = t3 +difftime(end.time,start.time, units = "secs")
}
}
val = c(z_l, p, sum(LB_w[-C]),sum(LB_p[-C]))
start.time = Sys.time()
temp = RS_C(lst,C,Aplus,Aminus,val)
end.time = Sys.time()
t1 = t1 +difftime(end.time,start.time, units = "secs")
lst = temp$lst
z_l = temp$z
if(sum(C) == sum(1:length(coeflist2))|ncol(lst) == 0){break}
i = cminus[b]
b = b + 1
if(Cs[i] == 0){
Cs[i] = i
C = rev(Cs[Cs])
start.time = Sys.time()
R = RC_C(coeflist2[[i]],Lpres$obj-LB_p[i]+alpha*(cw+LB_w[i]),alpha,z_l)
end.time = Sys.time()
t2 = t2 +difftime(end.time,start.time, units = "secs")
if(ncol(R)>1){
start.time = Sys.time()
lst = add_C(lst, R, p)
end.time = Sys.time()
t3 = t3 +difftime(end.time,start.time, units = "secs")
}
}
}
end = Sys.time()
t4 = difftime(end,start, units = "secs")
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
t1 = 0
t2 = 0
t3 = 0
start = Sys.time()
repeat{
val = c(z_l, p, sum(LB_w[-C]),sum(LB_p[-C]))
start.time = Sys.time()
temp = RS_C(lst,C,Aplus,Aminus,val)
end.time = Sys.time()
t1 = t1 +difftime(end.time,start.time, units = "secs")
lst = temp$lst
z_l = temp$z
if(sum(C) == sum(1:length(coeflist2))|ncol(lst) == 0){break}
i = cplus[a]
a = a + 1
if(Cs[i] == 0){
Cs[i] = i
C = rev(Cs[Cs])
start.time = Sys.time()
R = RC_C(coeflist2[[i]],Lpres$obj-LB_p[i]+alpha*(cw+LB_w[i]),alpha,z_l)
end.time = Sys.time()
t2 = t2 +difftime(end.time,start.time, units = "secs")
if(ncol(R)>1){
start.time = Sys.time()
lst = add_C(lst, R, p)
end.time = Sys.time()
t3 = t3 +difftime(end.time,start.time, units = "secs")
}
}
val = c(z_l, p, sum(LB_w[-C]),sum(LB_p[-C]))
start.time = Sys.time()
temp = RS_C(lst,C,Aplus,Aminus,val)
end.time = Sys.time()
t1 = t1 +difftime(end.time,start.time, units = "secs")
lst = temp$lst
z_l = temp$z
if(sum(C) == sum(1:length(coeflist2))|ncol(lst) == 0){break}
i = cminus[b]
b = b + 1
if(Cs[i] == 0){
Cs[i] = i
C = rev(Cs[Cs])
start.time = Sys.time()
R = RC_C(coeflist2[[i]],Lpres$obj-LB_p[i]+alpha*(cw+LB_w[i]),alpha,z_l)
end.time = Sys.time()
t2 = t2 +difftime(end.time,start.time, units = "secs")
if(ncol(R)>1){
start.time = Sys.time()
lst = add_C(lst, R, p)
end.time = Sys.time()
t3 = t3 +difftime(end.time,start.time, units = "secs")
}
}
}
end = Sys.time()
t4 = difftime(end,start, units = "secs")
length(coeflist)
coeflist[[1]]
c(t1,t2,t3,t4)
p
Mcknap(coeflist, N-k)
BB_Mcknap_C(coeflist, N-k)
set.seed(10)
n = 100
B = 900
N = n*B
block = rep(1:B, each = n)
Z = rep(rep(c(0,1), each = n/2), B)
Y = rnorm(N) + Z
k = floor(N*0.7)
method.list.all = list()
if(i %in% 1:2){
method.list.all[[1]] = list(name = "Wilcoxon")
}else{
method.list.all[[1]] = list(name = "Stephenson", s = 3)
}
min_stat_block(Z, Y, block, k, c=0,  method.list.all, opt.method = "ILP")
set.seed(10)
for(i in 1:5){
for(j in 1:3){
n = n_range[i]
B = B_range[j]
N = n*B
block = rep(1:B, each = n)
Z = rep(rep(c(0,1), each = n/2), B)
Y = rnorm(N) + Z
k = floor(N*0.9)
method.list.all = list()
if(i %in% 1:2){
method.list.all[[1]] = list(name = "Wilcoxon")
}else{
method.list.all[[1]] = list(name = "Stephenson", s = 3)
}
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
start.time = Sys.time()
val_LP = c(val_LP, Lpsolve_sol(coeflist, N - k, exact = FALSE))
end.time = Sys.time()
LP = c(LP, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
val_Gdn = c(val_Gdn, LpGreedy_On(coeflist, N - k)$obj)
end.time = Sys.time()
Gdn = c(Gdn, difftime(end.time,start.time, units = "secs"))
val_ILP = c(val_ILP, Lpsolve_sol(coeflist, N - k, exact = TRUE))
end.time = Sys.time()
ILP = c(ILP, difftime(end.time,start.time, units = "secs"))
}}
cbind(LP,ILP,Gdn)
cbind(val_LP,val_ILP,val_Gdn)
n_range = c(2,4,10, 50,100)
B_range = c(100,500,900)
LP = NULL
Gdn = NULL
Dp = NULL
DKW = NULL
Mcknap = NULL
ILP = NULL
LP_G = NULL
ILP_G = NULL
val_LP = NULL
val_Gdn = NULL
val_Dp = NULL
val_DKW = NULL
val_Mcknap = NULL
val_ILP = NULL
val_LP_G = NULL
val_ILP_G = NULL
set.seed(1234)
for(i in 1:5){
for(j in 1:3){
n = n_range[i]
B = B_range[j]
N = n*B
block = rep(1:B, each = n)
Z = rep(rep(c(0,1), each = n/2), B)
Y = rnorm(N) + Z
k = floor(N*0.9)
method.list.all = list()
if(i %in% 1:2){
method.list.all[[1]] = list(name = "Wilcoxon")
}else{
method.list.all[[1]] = list(name = "Stephenson", s = 3)
}
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
start.time = Sys.time()
val_LP = c(val_LP, Lpsolve_sol(coeflist, N - k, exact = FALSE))
end.time = Sys.time()
LP = c(LP, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
val_Gdn = c(val_Gdn, LpGreedy_On(coeflist, N - k)$obj)
end.time = Sys.time()
Gdn = c(Gdn, difftime(end.time,start.time, units = "secs"))
val_ILP = c(val_ILP, Lpsolve_sol(coeflist, N - k, exact = TRUE))
end.time = Sys.time()
ILP = c(ILP, difftime(end.time,start.time, units = "secs"))
}}
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
n = 10
B = 10
N = n*B
block = rep(1:B, each = n)
Z = rep(rep(c(0,1), each = n/2), B)
Y = rnorm(N) + Z
k = floor(N*0.9)
method.list.all = list()
if(i %in% 1:2){
method.list.all[[1]] = list(name = "Wilcoxon")
}else{
method.list.all[[1]] = list(name = "Stephenson", s = 3)
}
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
DP_C(coeflist,10)
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
coeflist
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
DP_C(coeflist,10)
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
DP_C(coeflist,10)
coeflist
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
DP_C(coeflist,10)
DynamicProgram(coeflist,10)
set.seed(10)
n = 100
B = 500
N = n*B
block = rep(1:B, each = n)
Z = rep(rep(c(0,1), each = n/2), B)
Y = rnorm(N) + Z
k = floor(N*0.9)
method.list.all = list()
if(i %in% 1:2){
method.list.all[[1]] = list(name = "Wilcoxon")
}else{
method.list.all[[1]] = list(name = "Stephenson", s = 3)
}
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
C = vector()
R = vector()
valC = vector()
valR = vector()
start.time = Sys.time()
valR = c(valR, LpGreedy_On(coeflist, N-k))
end.time = Sys.time()
R = c(R, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, LpGreedy_On(coeflist, N-k))
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valR = c(valR, DynamicProgram(coeflist, N-k))
end.time = Sys.time()
R = c(R, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, DP_C(coeflist, N-k))
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
cbind(R,C)
valR
C = vector()
start.time = Sys.time()
valC = c(valC, LpGreedy_On_C(coeflist, N-k))
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, DP_C(coeflist, N-k))
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
C = vector()
valC = vector()
start.time = Sys.time()
valC = c(valC, LpGreedy_On_C(coeflist, N-k)$obj)
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, DP_C(coeflist, N-k)$obj)
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
valC
cbind(C,R)
Lpsolve = vector()
start.time = Sys.time()
a = Lpsolve_sol(coeflist, N-k, exact = FALSE)
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
a = Lpsolve_sol(coeflist, N-k, exact = TRUE)
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
library(lpSolveAPI)
Lpsolve = vector()
start.time = Sys.time()
a = Lpsolve_sol(coeflist, N-k, exact = FALSE)
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
a = Lpsolve_sol(coeflist, N-k, exact = TRUE)
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
cbind(C,R,Lpsolve)
C = vector()
R = vector()
valC = vector()
valR = vector()
start.time = Sys.time()
valR = c(valR, LpGreedy_On(coeflist, N-k)$obj)
end.time = Sys.time()
R = c(R, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, LpGreedy_On_C(coeflist, N-k)$obj)
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valR = c(valR, DynamicProgram(coeflist, N-k)$obj)
end.time = Sys.time()
R = c(R, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, DP_C(coeflist, N-k)$obj)
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
Lpsolve = vector()
Lval = vector()
start.time = Sys.time()
Lval = c(Lval, Lpsolve_sol(coeflist, N-k, exact = FALSE))
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
Lval = c(Lval, Lpsolve_sol(coeflist, N-k, exact = TRUE))
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
cbind(C,R,Lpsolve)
cbind(valC,valR,Lval)
block_conf_quant_larger <- function(Z, Y, block, method.list.all = NULL, opt.method = 'Greedy', stat.null = NULL, sw = FALSE, null.max = 10^5,  alpha = 0.1){
if(!is.factor(block)){
block = as.factor(block)
}
n = length(Z)
mn = sum(Z)
B = length(levels(block))
if(sw){
nb = rep(NA, B)
zb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == levels(block)[i])
zb[i] = sum(Z[block == levels(block)[i]])
}
for(i in 1:B){
if(zb[i]<nb[i]/2){
Z[block == levels(block)[i]] = 1 - Z[block == levels(block)[i]]
Y[block == levels(block)[i]] = -Y[block == levels(block)[i]]
}
}
}
if(is.null(stat.null)){
stat.null =null_dist_block(Z,block, method.list.all = method.list.all, null.max = null.max)
}
# > threshold <===> p-value <= alpha #
thres = sort(stat.null, decreasing = TRUE)[ floor(length(stat.null) * alpha) + 1]
c_conf = rep(NA, n)
# range of c #
cup = max(Y[Z==1]) - min(Y[Z==0]) + 0.01
for(k in n:(n-mn)){
cdown = min(Y[Z==1]) - max(Y[Z==0]) - 0.01
up = min_stat_block(Z,Y,block,k,cdown,method.list.all,opt.method)
if(up<thres){
c_conf[1:k] = -Inf
break
}else{
repeat{
cmid = (cup+cdown)/2
mid = min_stat_block(Z,Y,block,k,cmid,method.list.all,opt.method)
if(mid>thres){
cdown = cmid
}else{
cup = cmid
}
if(abs(cup-cdown)<1e-6){
c_conf[k] = cmid
break
}
}
}
}
return( c_conf )
}
set.seed(10)
n = 10
B = 10
N = n*B
block = rep(1:B, each = n)
Z = rep(rep(c(0,1), each = n/2), B)
Y = rnorm(N) + Z
k = floor(N*0.9)
method.list.all = list()
method.list.all[[1]] = list(name = "Stephenson", s = 3)
block_conf_quant_larger(Z,Y,block,method.list.all)
library(bigmatch)
library(bigmatch)
install.packages("C:/Users/asus/Downloads/bigmatch_0.6.2.tar.gz", repos = NULL, type = "source")
install.packages(c('rcbalance', 'liqueueR', 'mvnfast'))
install.packages(c("rcbalance", "liqueueR", "mvnfast"))
t
t
t
t
t = 2
### set work directory to path where QIoT is at
setwd("C:/Users/asus/Box/Stratified Quantile")
library(devtools)
install("QIoT")
setwd("C:/Users/asus/Box/Stratified Quantile/QIoT")
devtools::document()
devtools::document()
