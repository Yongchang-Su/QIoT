Z = rep(rep(c(0,1), each = n/2), B)
Y = rnorm(N) + Z
k = floor(N*0.9)
method.list.all = list()
if(i %in% 1:2){
method.list.all[[1]] = list(name = "Wilcoxon")
}else{
method.list.all[[1]] = list(name = "Stephenson", s = 3)
}
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
start.time = Sys.time()
val_LP = c(val_LP, Lpsolve_sol(coeflist, N - k, exact = FALSE))
end.time = Sys.time()
LP = c(LP, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
val_Gdn = c(val_Gdn, LpGreedy_On(coeflist, N - k)$obj)
end.time = Sys.time()
Gdn = c(Gdn, difftime(end.time,start.time, units = "secs"))
val_ILP = c(val_ILP, Lpsolve_sol(coeflist, N - k, exact = TRUE))
end.time = Sys.time()
ILP = c(ILP, difftime(end.time,start.time, units = "secs"))
}}
cbind(LP,ILP,Gdn)
cbind(val_LP,val_ILP,val_Gdn)
n_range = c(2,4,10, 50,100)
B_range = c(100,500,900)
LP = NULL
Gdn = NULL
Dp = NULL
DKW = NULL
Mcknap = NULL
ILP = NULL
LP_G = NULL
ILP_G = NULL
val_LP = NULL
val_Gdn = NULL
val_Dp = NULL
val_DKW = NULL
val_Mcknap = NULL
val_ILP = NULL
val_LP_G = NULL
val_ILP_G = NULL
set.seed(1234)
for(i in 1:5){
for(j in 1:3){
n = n_range[i]
B = B_range[j]
N = n*B
block = rep(1:B, each = n)
Z = rep(rep(c(0,1), each = n/2), B)
Y = rnorm(N) + Z
k = floor(N*0.9)
method.list.all = list()
if(i %in% 1:2){
method.list.all[[1]] = list(name = "Wilcoxon")
}else{
method.list.all[[1]] = list(name = "Stephenson", s = 3)
}
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
start.time = Sys.time()
val_LP = c(val_LP, Lpsolve_sol(coeflist, N - k, exact = FALSE))
end.time = Sys.time()
LP = c(LP, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
val_Gdn = c(val_Gdn, LpGreedy_On(coeflist, N - k)$obj)
end.time = Sys.time()
Gdn = c(Gdn, difftime(end.time,start.time, units = "secs"))
val_ILP = c(val_ILP, Lpsolve_sol(coeflist, N - k, exact = TRUE))
end.time = Sys.time()
ILP = c(ILP, difftime(end.time,start.time, units = "secs"))
}}
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
n = 10
B = 10
N = n*B
block = rep(1:B, each = n)
Z = rep(rep(c(0,1), each = n/2), B)
Y = rnorm(N) + Z
k = floor(N*0.9)
method.list.all = list()
if(i %in% 1:2){
method.list.all[[1]] = list(name = "Wilcoxon")
}else{
method.list.all[[1]] = list(name = "Stephenson", s = 3)
}
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
DP_C(coeflist,10)
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
coeflist
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
DP_C(coeflist,10)
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
DP_C(coeflist,10)
coeflist
Rcpp::sourceCpp("C:/Users/asus/Desktop/treatment quantile/Mcknap_C.cpp")
DP_C(coeflist,10)
DynamicProgram(coeflist,10)
set.seed(10)
n = 100
B = 500
N = n*B
block = rep(1:B, each = n)
Z = rep(rep(c(0,1), each = n/2), B)
Y = rnorm(N) + Z
k = floor(N*0.9)
method.list.all = list()
if(i %in% 1:2){
method.list.all[[1]] = list(name = "Wilcoxon")
}else{
method.list.all[[1]] = list(name = "Stephenson", s = 3)
}
coeflist = test_stat_matrix_block(Z, Y, block, c=0, method.list.all)
C = vector()
R = vector()
valC = vector()
valR = vector()
start.time = Sys.time()
valR = c(valR, LpGreedy_On(coeflist, N-k))
end.time = Sys.time()
R = c(R, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, LpGreedy_On(coeflist, N-k))
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valR = c(valR, DynamicProgram(coeflist, N-k))
end.time = Sys.time()
R = c(R, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, DP_C(coeflist, N-k))
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
cbind(R,C)
valR
C = vector()
start.time = Sys.time()
valC = c(valC, LpGreedy_On_C(coeflist, N-k))
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, DP_C(coeflist, N-k))
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
C = vector()
valC = vector()
start.time = Sys.time()
valC = c(valC, LpGreedy_On_C(coeflist, N-k)$obj)
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, DP_C(coeflist, N-k)$obj)
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
valC
cbind(C,R)
Lpsolve = vector()
start.time = Sys.time()
a = Lpsolve_sol(coeflist, N-k, exact = FALSE)
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
a = Lpsolve_sol(coeflist, N-k, exact = TRUE)
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
library(lpSolveAPI)
Lpsolve = vector()
start.time = Sys.time()
a = Lpsolve_sol(coeflist, N-k, exact = FALSE)
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
a = Lpsolve_sol(coeflist, N-k, exact = TRUE)
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
cbind(C,R,Lpsolve)
C = vector()
R = vector()
valC = vector()
valR = vector()
start.time = Sys.time()
valR = c(valR, LpGreedy_On(coeflist, N-k)$obj)
end.time = Sys.time()
R = c(R, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, LpGreedy_On_C(coeflist, N-k)$obj)
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valR = c(valR, DynamicProgram(coeflist, N-k)$obj)
end.time = Sys.time()
R = c(R, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
valC = c(valC, DP_C(coeflist, N-k)$obj)
end.time = Sys.time()
C = c(C, difftime(end.time,start.time, units = "secs"))
Lpsolve = vector()
Lval = vector()
start.time = Sys.time()
Lval = c(Lval, Lpsolve_sol(coeflist, N-k, exact = FALSE))
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
start.time = Sys.time()
Lval = c(Lval, Lpsolve_sol(coeflist, N-k, exact = TRUE))
end.time = Sys.time()
Lpsolve = c(Lpsolve, difftime(end.time,start.time, units = "secs"))
cbind(C,R,Lpsolve)
cbind(valC,valR,Lval)
block_conf_quant_larger <- function(Z, Y, block, method.list.all = NULL, opt.method = 'Greedy', stat.null = NULL, sw = FALSE, null.max = 10^5,  alpha = 0.1){
if(!is.factor(block)){
block = as.factor(block)
}
n = length(Z)
mn = sum(Z)
B = length(levels(block))
if(sw){
nb = rep(NA, B)
zb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == levels(block)[i])
zb[i] = sum(Z[block == levels(block)[i]])
}
for(i in 1:B){
if(zb[i]<nb[i]/2){
Z[block == levels(block)[i]] = 1 - Z[block == levels(block)[i]]
Y[block == levels(block)[i]] = -Y[block == levels(block)[i]]
}
}
}
if(is.null(stat.null)){
stat.null =null_dist_block(Z,block, method.list.all = method.list.all, null.max = null.max)
}
# > threshold <===> p-value <= alpha #
thres = sort(stat.null, decreasing = TRUE)[ floor(length(stat.null) * alpha) + 1]
c_conf = rep(NA, n)
# range of c #
cup = max(Y[Z==1]) - min(Y[Z==0]) + 0.01
for(k in n:(n-mn)){
cdown = min(Y[Z==1]) - max(Y[Z==0]) - 0.01
up = min_stat_block(Z,Y,block,k,cdown,method.list.all,opt.method)
if(up<thres){
c_conf[1:k] = -Inf
break
}else{
repeat{
cmid = (cup+cdown)/2
mid = min_stat_block(Z,Y,block,k,cmid,method.list.all,opt.method)
if(mid>thres){
cdown = cmid
}else{
cup = cmid
}
if(abs(cup-cdown)<1e-6){
c_conf[k] = cmid
break
}
}
}
}
return( c_conf )
}
set.seed(10)
n = 10
B = 10
N = n*B
block = rep(1:B, each = n)
Z = rep(rep(c(0,1), each = n/2), B)
Y = rnorm(N) + Z
k = floor(N*0.9)
method.list.all = list()
method.list.all[[1]] = list(name = "Stephenson", s = 3)
block_conf_quant_larger(Z,Y,block,method.list.all)
library(bigmatch)
library(bigmatch)
install.packages("C:/Users/asus/Downloads/bigmatch_0.6.2.tar.gz", repos = NULL, type = "source")
install.packages(c('rcbalance', 'liqueueR', 'mvnfast'))
install.packages(c("rcbalance", "liqueueR", "mvnfast"))
t
t
t
t
t = 2
### set work directory to path where QIoT is at
setwd("C:/Users/asus/Box/Stratified Quantile")
library(devtools)
install("QIoT")
install_github("Yongchang-Su/QIoT")
# b5 = as.factor(paste0("E", as.character(match_Res5)))
#
# data1$block = b1
# data2$block = b2
# data3$block = b3
# data4$block = b4
# data5$block = b5
#
# data_stratified = rbind(data1,data2,data3,data4,data5)
# saveRDS(data_stratified, 'data_analysis/data_stratified.rds')
library(devtools)
install_github("Yongchang-Su/QIoT")
install.packages("usethis")
# b5 = as.factor(paste0("E", as.character(match_Res5)))
#
# data1$block = b1
# data2$block = b2
# data3$block = b3
# data4$block = b4
# data5$block = b5
#
# data_stratified = rbind(data1,data2,data3,data4,data5)
# saveRDS(data_stratified, 'data_analysis/data_stratified.rds')
library(devtools)
install.packages("installr")
library(installr)
updateR()
n=10
s = 0
for(i in 1:n){
s = s+choose(2*n-i-1,n-1)/2^(2*n-i-1)
}
s
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
library(gurobi)
library(devtools)
require(gurobi)
# libraries for simulation data generation
library(psych)
library(randomizr)
install.packages(c("psych","randomizr"))
com_working = function(Z, Y, block, c, methods.list.all){
if(!is.factor(block)){
block = as.factor(block)
}
total.list = list()
n = length(methods.list.all)
N = length(Y)
B = length(levels(block))
block.levels = levels(block)
## calculate numbers of observations in each block
nb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == block.levels[i])
}
for (l in 1:n){
method.list.all = methods.list.all[[l]]
Tlist = list()
for(i in 1:B){
Zb = Z[block == block.levels[i]]
Yb = Y[block == block.levels[i]]
Ti = matrix(nrow = 2, ncol = nb[i] + 1)
Ti[1,] = 0:nb[i]
for(ii in 0:nb[i]){
if(length(method.list.all)==1){
method.list = method.list.all[[1]]
}else{
method.list = method.list.all[[i]]
}
Ti[2, ii+1] = min_stat(Zb, Yb, nb[i]-ii, c, method.list = method.list)
}
Tlist[[i]] = Ti
}
total.list[[l]] <- Tlist
}
return(total.list)
}
​
########################################################
### function for implement Gurobi for our ILP problem
########################################################
## two major changes:
##  (1) change in objective function statement
##  (2) allow eta to have negative value
​
​
Gurobi_sol_com <- function(coeflists, p, exact = TRUE){
model = list()
Q = NULL
H = length(coeflists)
B = length(coeflists[[1]])
nb = vector(length = B)
for (h in 1 : H){
coeflist = coeflists[[h]]
for (i in 1 : B){
Q = c(Q, coeflist[[i]][2,])
}
}
Q1 <- c(rep(0, length(Q)), 1)
#  Q1 <- c(Q, 1)
A_final <- c(Q, -1)    ## will add this as a final constraint
for (i in 1 : B){
nb[i] = ncol(coeflist[[i]]) ## this does not change by choice of SRSS(Stratified Rank Sum Statistic)
}
HB = H * B
nb2 = rep(nb, length(coeflists))  ## added
n = length(Q1)
A = matrix(0, nrow = H * (B + 1) + 1, ncol = n) ## added one row one column each
indx = c(0, cumsum(nb2))
for (i in 1 : HB){
A[i, (indx[i] + 1):indx[i+1]] = 1
}
for (h in 1 : H){
for (i in 1 : B) {
A[HB + h,  ((h-1) * sum(nb)+1) : (h * sum(nb))]  =
rep(coeflist[[i]][1,], B)
}
}
A[H * (B+1) + 1, ] = A_final
model$A = A
model$obj = Q1
model$modelsense = "min"
model$rhs = c(rep(1, HB), rep(p, H), 0)
model$sense = c(rep("=", HB), rep("<=", H), "<=" )
model$lb = c(rep(0, length(Q)), -Inf)
#  model$vtype = vec(B = length = length(Q1))
if(exact){
model$vtype = c(rep("B", length(Q)), "C")
}
gurobi(model)           ## can omit this when we only want to check the output, not the optimization process
params <- list(OutputFlag = 0)
result = gurobi::gurobi(model,params)
return(list(sol = result$x, obj = result$objval))
}
s = 20
n = 50
m = 0.5 * n
N = s * n
k = ceiling(0.9 * N)
p = N - k
c = 0
​
simulation_Z <- as.data.frame(block.random(n = N, c(block = s)))
​
simulation_Z$block <- as.factor(simulation_Z$block)
# libraries for simulation data generation
library(psych)
library(randomizr)
s = 20
n = 50
m = 0.5 * n
N = s * n
k = ceiling(0.9 * N)
p = N - k
c = 0
​
simulation_Z <- as.data.frame(block.random(n = N, c(block = s)))
​
simulation_Z$block <- as.factor(simulation_Z$block)
head(simulation_Z)
levels(simulation_Z$block)
test_Z <- block_ra(blocks = simulation_Z$block)
table(test_Z, simulation_Z$block)
​
Y1 = 2 + rnorm(N)
Y0 = rnorm(N)
​
Z = block_ra(blocks = simulation_Z$block)
Y = Z * Y1 + (1-Z) * Y0
Z_block <- simulation_Z$block
table(test_Z, simulation_Z$block)
Y1 = 2 + rnorm(N)
Y0 = rnorm(N)
method.list.all.4 <- list()
method.list.4 = list(name = "Stephenson",
s = 15,
standardize = TRUE
)
for (i in 1 : s) method.list.all.4[[i]] <- method.list.4
coeflists = com_working(Z, Y, block = Z_block, c = c, methods.list.all = methods.list.all)
coeflists = com_working(Z, Y, block = Z_block, c = c, methods.list.all = methods.list.all.4)
methods.list.all <- list(method.list.all.4)
coeflists = com_working(Z, Y, block = Z_block, c = c, methods.list.all = methods.list.all)
Gurobi_sol_com(coeflists, p, exact = TRUE)
install.packages("c:/gurobi950/win64/R/gurobi_9.5-0.zip", repos = NULL)
library(gurobi)
install.packages("slam")
Gurobi_sol_com(coeflists, p, exact = TRUE)
library(gurobi)
Gurobi_sol_com(coeflists, p, exact = TRUE)
QIoT::min_stat_block(Z, Y, Z_block, k, c, method.list.all, opt.method = "ILP")
QIoT::min_stat_block
QIoT::min_stat_block(Z, Y, Z_block, k, c, method.list.all, opt.method = "DP")
flag = (Z == 1)
s = sum(flag)
comb[1:s, 2] = Y[flag]
comb[(s + 1):N, 2] = Y[!flag]
comb[, 1] = c(rep(1, s), rep(0, N - s))
comb = comb[order(comb[, 2]), ]
comb = matrix(nrow = N, ncol = 3)
flag = (Z == 1)
s = sum(flag)
comb[1:s, 2] = Y[flag]
comb[(s + 1):N, 2] = Y[!flag]
comb[, 1] = c(rep(1, s), rep(0, N - s))
comb = comb[order(comb[, 2]), ]
comb
y1 = comb[,1]
flag = (Z == 0)
s = sum(flag)
comb[1:s, 2] = Y[flag]
comb[(s + 1):N, 2] = Y[!flag]
comb[, 1] = c(rep(0, s), rep(1, N - sum(flag)))
comb = comb[order(comb[, 2]), ]
y2 = comb[,1]
all.equal(y1,y2)
setwd("C:/Users/asus/Box/Stratified Quantile/QIoT")
library(devtools)
document()
rm(list = c("block_conf_quant_larger", "min_stat_block", "null_dist_block", "pval_block", "pval_block_sides",
"sen_block_conf_quant_larger", "sen_ls_p"))
document()
