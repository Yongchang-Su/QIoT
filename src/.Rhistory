}
if(opt.method == "DP"){
start = Sys.time()
stat = DP_C(coeflist, N - k)$obj
end = Sys.time()
t2 = difftime(end,start,units = "secs")
}
if(opt.method == "LP"){
stat = Lpsolve_sol(coeflist, N - k, exact = FALSE)
}
if(opt.method == "ILP"){
stat = Lpsolve_sol(coeflist, N - k, exact = TRUE)
}
output$upper = stat
output$time = c(t1,t2)
}
if(2 %in% ties){
flag = (Z==1)
comb[,3] = block
comb[1:sum(flag),2] = Y[flag]
comb[(sum(flag)+1):N,2] = Y[!flag]
comb[1:sum(flag),3] = block[flag]
comb[(sum(flag)+1):N,3] = block[!flag]
comb[,1] = c(rep(1, sum(flag)), rep(0, N-sum(flag)))
comb = comb[order(comb[,2]),]
Z1 = comb[,1]
Y1 = comb[,2]
block1 = comb[,3]
coeflist = test_stat_matrix_block_oldversion(Z1, Y1, block1, c, method.list.all)
if(opt.method == "Greedy"){
stat = LpGreedy_On_C(coeflist, N - k)$obj
}
if(opt.method == "DP"){
stat = DP_C(coeflist, N - k)$obj
}
if(opt.method == "LP"){
stat = Lpsolve_sol(coeflist, N - k, exact = FALSE)
}
if(opt.method == "ILP"){
stat = Lpsolve_sol(coeflist, N - k, exact = TRUE)
}
output$lower = stat
}
if(3 %in% ties){
comb = cbind(Z, Y, block)
shuffle = sample(1:N, N)
comb = comb[shuffle, ]
comb = comb[order(comb[,2]),]
Z3 = comb[,1]
Y3 = comb[,2]
block3 = comb[,3]
coeflist = test_stat_matrix_block_oldversion(Z, Y, block, c, method.list.all)
if(opt.method == "Greedy"){
stat = LpGreedy_On_C(coeflist, N - k)$obj
}
if(opt.method == "DP"){
stat = DP_C(coeflist, N - k)$obj
}
if(opt.method == "LP"){
stat = Lpsolve_sol(coeflist, N - k, exact = FALSE)
}
if(opt.method == "ILP"){
stat = Lpsolve_sol(coeflist, N - k, exact = TRUE)
}
output$random = stat
}
return(output)
}
null_dist_block_old<- function(Z,block, method.list.all, Gam = 1, null.max = 10^5, Z.perm.all = NULL){
if(!is.factor(block)){
block = as.factor(block)
}
N = length(Z)
B = length(levels(block))
b_num = as.vector(table(block))
block.levels = levels(block)
if(Gam>1){
Ts = list()
Ps = list()
for(i in 1:B){
n = b_num[i]
if(length(method.list.all)==1){
method.list = method.list.all[[1]]
}else{
method.list = method.list.all[[i]]
}
r = rank_score(n, method.list)
Ts[[i]] = order(unique(r), decreasing = FALSE)
g = rev(cumsum(rev(as.vector(table(r)))))
p = g*Gam/((n-g)+g*Gam)
Ps[[i]] = p - c(p[2:length(p)],0)
}
stat_null = rep(0, null.max)
for(i in 1:B){
stat_null = stat_null + sample(Ts[[i]], null.max, replace = TRUE, prob = Ps[[i]])
}
}else{
nb = rep(NA, B)
mb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == block.levels[i])
mb[i] = sum( Z[block == block.levels[i]] )
}
## get the corresponding value of test statistics
stat.null = rep(0, null.max)
for(i in 1:B){
if(length(method.list.all)==1){
method.list = method.list.all[[1]]
}else{
method.list = method.list.all[[i]]
}
## get permuted treatment assignment
if(is.null(Z.perm.all)){
Z.perm.i = matrix(nrow = nb[i], ncol = null.max)
for(iter in 1:null.max){
Z.perm.i[,iter] = sample( c(rep(1, mb[i]), rep(0, nb[i] - mb[i])) )
}
}else{
for(iter in 1:null.max){
Z.perm.i = Z.perm.all[block == block.levels[i], ]
}
Z.perm.i = Z.perm.all[block == block.levels[i], ]
}
stat.null = stat.null + null_dist(nb[i], mb[i], method.list = method.list, Z.perm = Z.perm.i)
}
}
return(stat.null)
}
setwd("C:/Users/asus/Box/Stratified Quantile/Code_1st_Submission")
o = readRDS("o.rds")
md <- o$data
Y = md$cadmium
block = md$mset
Z = md$z
method.list.all = list()
method.list.all[[1]] = list(name = "Wilcoxon")
#######
if(!is.factor(block)){
block = as.factor(block)
}
n = length(Z)
mn = sum(Z)
B = length(levels(block))
nb = rep(NA, B)
zb = rep(NA, B)
for(i in 1:B){
nb[i] = sum(block == levels(block)[i])
zb[i] = sum(Z[block == levels(block)[i]])
}
for(i in 1:B){
if(zb[i]<nb[i]/2){
Z[block == levels(block)[i]] = 1 - Z[block == levels(block)[i]]
Y[block == levels(block)[i]] = -Y[block == levels(block)[i]]
}
}
t = rep(0, 4)
start = Sys.time()
stat.null =null_dist_block_old(Z,block, method.list.all = method.list.all, null.max = null.max)
end = Sys.time()
t[1] = difftime(end,start,units = "secs")
null_dist
source("C:/Users/asus/Box/Stratified Quantile/Code_2nd_Submission/RI_Quantile.R")
t = rep(0, 4)
start = Sys.time()
stat.null =null_dist_block_old(Z,block, method.list.all = method.list.all, null.max = null.max)
end = Sys.time()
t[1] = difftime(end,start,units = "secs")
null.max
null.max = 10^5
t = rep(0, 4)
start = Sys.time()
stat.null =null_dist_block_old(Z,block, method.list.all = method.list.all, null.max = null.max)
end = Sys.time()
t[1] = difftime(end,start,units = "secs")
# > threshold <===> p-value <= alpha #
thres = sort(stat.null, decreasing = TRUE)[ floor(length(stat.null) * alpha) + 1]
c_conf1 = rep(NA, n)
# range of c #
cup = max(Y[Z==1]) - min(Y[Z==0]) + 0.01
for(k in n:(n-mn)){
cdown = min(Y[Z==1]) - max(Y[Z==0]) - 0.01
res = min_stat_block(Z,Y,block,k,cdown,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
up = res$upper
if(up<thres){
c_conf1[1:k] = -Inf
break
}else{
repeat{
cmid = (cup+cdown)/2
res = min_stat_block(Z,Y,block,k,cmid,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
up = res$upper
if(mid>thres){
cdown = cmid
}else{
cup = cmid
}
if(abs(cup-cdown)<1e-6){
c_conf1[k] = cmid
break
}
}
}
}
t
# > threshold <===> p-value <= alpha #
thres = sort(stat.null, decreasing = TRUE)[ floor(length(stat.null) * alpha) + 1]
c_conf1 = rep(NA, n)
# range of c #
cup = max(Y[Z==1]) - min(Y[Z==0]) + 0.01
for(k in n:(n-mn)){
cdown = min(Y[Z==1]) - max(Y[Z==0]) - 0.01
res = min_stat_block(Z,Y,block,k,cdown,method.list.all,opt.method = "Greedy")
t[2:3] = t[2:3] + res$time
up = res$upper
if(up<thres){
c_conf1[1:k] = -Inf
break
}else{
repeat{
cmid = (cup+cdown)/2
res = min_stat_block(Z,Y,block,k,cmid,method.list.all,opt.method = "Greedy")
t[2:3] = t[2:3] + res$time
up = res$upper
if(mid>thres){
cdown = cmid
}else{
cup = cmid
}
if(abs(cup-cdown)<1e-6){
c_conf1[k] = cmid
break
}
}
}
}
thres = sort(stat.null, decreasing = TRUE)[ floor(length(stat.null) * alpha) + 1]
c_conf1 = rep(NA, n)
# range of c #
cup = max(Y[Z==1]) - min(Y[Z==0]) + 0.01
for(k in n:(n-mn)){
cdown = min(Y[Z==1]) - max(Y[Z==0]) - 0.01
res = min_stat_block_oldversion(Z,Y,block,k,cdown,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
up = res$upper
if(up<thres){
c_conf1[1:k] = -Inf
break
}else{
repeat{
cmid = (cup+cdown)/2
res = min_stat_block_oldversion(Z,Y,block,k,cmid,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
up = res$upper
if(mid>thres){
cdown = cmid
}else{
cup = cmid
}
if(abs(cup-cdown)<1e-6){
c_conf1[k] = cmid
break
}
}
}
}
up
thres
alpha
alpha = 0.1
t
t[2:4] = 0
t
# > threshold <===> p-value <= alpha #
thres = sort(stat.null, decreasing = TRUE)[ floor(length(stat.null) * alpha) + 1]
c_conf1 = rep(NA, n)
# range of c #
cup = max(Y[Z==1]) - min(Y[Z==0]) + 0.01
for(k in n:(n-mn)){
cdown = min(Y[Z==1]) - max(Y[Z==0]) - 0.01
res = min_stat_block_oldversion(Z,Y,block,k,cdown,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
up = res$upper
if(up<thres){
c_conf1[1:k] = -Inf
break
}else{
repeat{
cmid = (cup+cdown)/2
res = min_stat_block_oldversion(Z,Y,block,k,cmid,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
up = res$upper
if(mid>thres){
cdown = cmid
}else{
cup = cmid
}
if(abs(cup-cdown)<1e-6){
c_conf1[k] = cmid
break
}
}
}
}
t[2:4] = 0
# > threshold <===> p-value <= alpha #
thres = sort(stat.null, decreasing = TRUE)[ floor(length(stat.null) * alpha) + 1]
c_conf1 = rep(NA, n)
# range of c #
cup = max(Y[Z==1]) - min(Y[Z==0]) + 0.01
for(k in n:(n-mn)){
cdown = min(Y[Z==1]) - max(Y[Z==0]) - 0.01
res = min_stat_block_oldversion(Z,Y,block,k,cdown,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
up = res$upper
if(up<thres){
c_conf1[1:k] = -Inf
break
}else{
repeat{
cmid = (cup+cdown)/2
res = min_stat_block_oldversion(Z,Y,block,k,cmid,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
mid = res$upper
if(mid>thres){
cdown = cmid
}else{
cup = cmid
}
if(abs(cup-cdown)<1e-6){
c_conf1[k] = cmid
break
}
}
}
}
t
t_withoutC_greedy = t
Rcpp::sourceCpp("Mcknap.cpp")
setwd("C:/Users/asus/Box/Stratified Quantile/QIoT/src")
Rcpp::sourceCpp("Mcknap.cpp")
Rcpp::sourceCpp("Mcknap.cpp")
null_dist_block
t = rep(0, 4)
start = Sys.time()
stat.null =null_dist_block(Z,block, method.list.all = method.list.all, null.max = null.max)
end = Sys.time()
t[1] = difftime(end,start,units = "secs")
t = rep(0, 4)
start = Sys.time()
stat.null =null_dist_block(Z,block, method_list_all = method.list.all, null_max = null.max)
end = Sys.time()
t[1] = difftime(end,start,units = "secs")
min_stat_block
# > threshold <===> p-value <= alpha #
thres = sort(stat.null, decreasing = TRUE)[ floor(length(stat.null) * alpha) + 1]
c_conf1 = rep(NA, n)
# range of c #
cup = max(Y[Z==1]) - min(Y[Z==0]) + 0.01
for(k in n:(n-mn)){
cdown = min(Y[Z==1]) - max(Y[Z==0]) - 0.01
res = min_stat_block(Z,Y,block,k,cdown,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
up = res$upper
if(up<thres){
c_conf1[1:k] = -Inf
break
}else{
repeat{
cmid = (cup+cdown)/2
res = min_stat_block(Z,Y,block,k,cmid,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
mid = res$upper
if(mid>thres){
cdown = cmid
}else{
cup = cmid
}
if(abs(cup-cdown)<1e-6){
c_conf1[k] = cmid
break
}
}
}
}
min_stat_block <- function(Z, Y, block, k, c, method.list.all, opt.method="Greedy", ties = c(1,2,3)){
N = length(Z)
output = list()
comb = matrix(nrow = N, ncol = 3)
if(1 %in% ties){
flag = (Z==0)
comb[,3] = block
comb[1:sum(flag),2] = Y[flag]
comb[(sum(flag)+1):N,2] = Y[!flag]
comb[1:sum(flag),3] = block[flag]
comb[(sum(flag)+1):N,3] = block[!flag]
comb[,1] = c(rep(0, sum(flag)), rep(1, N-sum(flag)))
comb = comb[order(comb[,2]),]
Z2 = comb[,1]
Y2 = comb[,2]
block2 = comb[,3]
start = Sys.time()
coeflist = test_stat_matrix_block(Z2, Y2, block2, c, method.list.all)
end = Sys.time()
t1 = difftime(end,start,units = "secs")
if(opt.method == "Greedy"){
start = Sys.time()
stat = LpGreedy_On_C(coeflist, N - k)$obj
end = Sys.time()
t2 = difftime(end,start,units = "secs")
}
if(opt.method == "DP"){
start = Sys.time()
stat = DP_C(coeflist, N - k)$obj
end = Sys.time()
t2 = difftime(end,start,units = "secs")
}
if(opt.method == "LP"){
stat = Lpsolve_sol(coeflist, N - k, exact = FALSE)
}
if(opt.method == "ILP"){
stat = Lpsolve_sol(coeflist, N - k, exact = TRUE)
}
output$upper = stat
output$time = c(t1,t2)
}
if(2 %in% ties){
flag = (Z==1)
comb[,3] = block
comb[1:sum(flag),2] = Y[flag]
comb[(sum(flag)+1):N,2] = Y[!flag]
comb[1:sum(flag),3] = block[flag]
comb[(sum(flag)+1):N,3] = block[!flag]
comb[,1] = c(rep(1, sum(flag)), rep(0, N-sum(flag)))
comb = comb[order(comb[,2]),]
Z1 = comb[,1]
Y1 = comb[,2]
block1 = comb[,3]
coeflist = test_stat_matrix_block(Z1, Y1, block1, c, method.list.all)
if(opt.method == "Greedy"){
stat = LpGreedy_On_C(coeflist, N - k)$obj
}
if(opt.method == "DP"){
stat = DP_C(coeflist, N - k)$obj
}
if(opt.method == "LP"){
stat = Lpsolve_sol(coeflist, N - k, exact = FALSE)
}
if(opt.method == "ILP"){
stat = Lpsolve_sol(coeflist, N - k, exact = TRUE)
}
output$lower = stat
}
if(3 %in% ties){
comb = cbind(Z, Y, block)
shuffle = sample(1:N, N)
comb = comb[shuffle, ]
comb = comb[order(comb[,2]),]
Z3 = comb[,1]
Y3 = comb[,2]
block3 = comb[,3]
coeflist = test_stat_matrix_block(Z, Y, block, c, method.list.all)
if(opt.method == "Greedy"){
stat = LpGreedy_On_C(coeflist, N - k)$obj
}
if(opt.method == "DP"){
stat = DP_C(coeflist, N - k)$obj
}
if(opt.method == "LP"){
stat = Lpsolve_sol(coeflist, N - k, exact = FALSE)
}
if(opt.method == "ILP"){
stat = Lpsolve_sol(coeflist, N - k, exact = TRUE)
}
output$random = stat
}
return(output)
}
# > threshold <===> p-value <= alpha #
thres = sort(stat.null, decreasing = TRUE)[ floor(length(stat.null) * alpha) + 1]
c_conf1 = rep(NA, n)
# range of c #
cup = max(Y[Z==1]) - min(Y[Z==0]) + 0.01
for(k in n:(n-mn)){
cdown = min(Y[Z==1]) - max(Y[Z==0]) - 0.01
res = min_stat_block(Z,Y,block,k,cdown,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
up = res$upper
if(up<thres){
c_conf1[1:k] = -Inf
break
}else{
repeat{
cmid = (cup+cdown)/2
res = min_stat_block(Z,Y,block,k,cmid,method.list.all,opt.method = "Greedy", ties = 1)
t[2:3] = t[2:3] + res$time
mid = res$upper
if(mid>thres){
cdown = cmid
}else{
cup = cmid
}
if(abs(cup-cdown)<1e-6){
c_conf1[k] = cmid
break
}
}
}
}
t
t_withoutC_greedy
